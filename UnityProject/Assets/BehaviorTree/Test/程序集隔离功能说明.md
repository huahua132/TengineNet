# 行为树程序集隔离功能说明

## 功能概述

此功能允许每个行为树资产配置其可以使用的程序集，从而实现节点的隔离和访问控制。这对于大型项目中需要区分不同模块的行为树非常有用。

## 核心概念

### 1. 归属程序集 (Owner Assembly)
- 行为树的主要程序集
- 该程序集中的所有节点都可被该行为树使用

### 2. 共享程序集 (Shared Assemblies)
- 可以被多个行为树共享的程序集列表
- 通常用于存放通用的、可复用的节点

### 3. 程序集过滤机制
- **编辑器**：根据配置动态过滤节点库中显示的节点
- **运行时**：在加载时验证节点的程序集归属，拒绝未授权的节点

## 实现的修改

### 1. BehaviorTreeAsset.cs
添加了程序集配置字段：
```csharp
public string ownerAssembly = "";
public List<string> sharedAssemblies = new List<string>();
```

新增方法：
- `GetAllowedAssemblies()` - 获取允许的程序集列表
- `IsAssemblyAllowed(string)` - 检查程序集是否被允许

### 2. BehaviorNodeRegistry.cs
扩展了节点类型信息：
```csharp
public string AssemblyName { get; set; }  // 记录节点所属程序集
```

新增过滤方法：
- `GetNodesByAssemblies(List<string>)` - 按程序集过滤节点
- `GetNodesByTypeAndAssemblies(BehaviorProcessType, List<string>)` - 按类型和程序集过滤

### 3. BehaviorTreeEditorWindow.cs
- 修改 `DrawNodeCategory()` 支持程序集过滤
- 新增 `DrawAssetInspector()` 显示程序集配置UI
- 节点库根据当前资产的程序集配置动态更新

### 4. BehaviorTree.cs (运行时)
- 在 `CreateNode()` 中添加程序集权限验证
- 如果节点来自未授权的程序集，输出错误并拒绝创建

## 测试程序集结构

### SharedTree
```
BehaviorTree/Test/SharedTree/
├── SharedTree.asmdef
└── SharedLogNode.cs
```
- **程序集名**: `BehaviorTree.SharedTree`
- **命名空间**: `BehaviorTree.SharedTree`
- **用途**: 共享节点，可被所有树使用

### Test1
```
BehaviorTree/Test/Test1/
├── Test1.asmdef
└── Test1ActionNode.cs
```
- **程序集名**: `BehaviorTree.Test1`
- **命名空间**: `BehaviorTree.Test1`
- **依赖**: BehaviorTree.SharedTree
- **用途**: Test1专属节点

### Test2
```
BehaviorTree/Test/Test2/
├── Test2.asmdef
└── Test2ActionNode.cs
```
- **程序集名**: `BehaviorTree.Test2`
- **命名空间**: `BehaviorTree.Test2`
- **依赖**: BehaviorTree.SharedTree
- **用途**: Test2专属节点

## 使用方法

### 在编辑器中配置

1. **打开行为树编辑器**
   - `Tools > BehaviorTree > Editor Window`

2. **创建或加载行为树资产**

3. **配置程序集**（在右侧Inspector面板）：
   - 点击空白处（不选中任何节点）
   - 设置 **归属程序集**：例如 `BehaviorTree.Test1`
   - 添加 **共享程序集**：点击"添加共享程序集"按钮，输入 `BehaviorTree.SharedTree`

4. **查看节点过滤效果**
   - 左侧节点库会自动更新
   - 只显示允许的程序集中的节点

### 配置示例

#### Test1行为树配置
```
归属程序集: BehaviorTree.Test1
共享程序集:
  - BehaviorTree.SharedTree
```
**可用节点**: Test1ActionNode, SharedLogNode

#### Test2行为树配置
```
归属程序集: BehaviorTree.Test2
共享程序集:
  - BehaviorTree.SharedTree
```
**可用节点**: Test2ActionNode, SharedLogNode

### 运行时测试

1. **创建测试场景**
2. **添加GameObject**
3. **挂载 `AssemblyTestRunner` 脚本**
4. **指定测试资产**
5. **运行场景或点击右键菜单 "Run Assembly Test"**

## 程序集配置规则

### 默认行为（无配置）
- 如果归属程序集和共享程序集都为空
- 行为树可以使用**所有可用节点**（向后兼容）

### 仅配置归属程序集
- 只能使用归属程序集中的节点

### 配置归属+共享程序集
- 可以使用归属程序集和所有共享程序集中的节点

### 仅配置共享程序集
- 只能使用共享程序集中的节点

## 错误处理

### 编辑器
- 如果配置了不存在的程序集名称，该程序集会被忽略
- 节点列表会正常显示其他有效程序集的节点

### 运行时
- 如果尝试加载包含未授权节点的行为树
- 控制台会输出详细错误信息：
  ```
  Node type 'XXX' from assembly 'YYY' is not allowed in this behavior tree.
  Allowed assemblies: ZZZ
  ```
- 该节点创建失败，但不影响其他节点

## 最佳实践

1. **模块化设计**
   - 为每个游戏模块创建独立的程序集
   - 例如：战斗系统、AI系统、任务系统

2. **共享通用节点**
   - 将通用节点放在共享程序集中
   - 例如：日志节点、等待节点、基础逻辑节点

3. **清晰的命名**
   - 使用描述性的程序集名称
   - 例如：`Game.AI.Combat`, `Game.AI.Navigation`

4. **文档化**
   - 为每个程序集创建说明文档
   - 记录包含哪些节点及其用途

## 注意事项

1. **程序集名称区分大小写**
   - `BehaviorTree.Test1` ≠ `behaviortree.test1`

2. **需要Unity识别.asmdef文件**
   - 确保.asmdef文件格式正确
   - 检查Project窗口中的程序集图标

3. **引用关系**
   - 如果程序集A依赖程序集B
   - 需要在A的.asmdef中添加对B的引用

4. **热重载**
   - 修改程序集配置后，编辑器会自动刷新
   - 如果未生效，尝试重新打开编辑器窗口

## 故障排查

### 问题：节点没有被过滤
**解决方案**：
- 检查程序集名称拼写
- 确认.asmdef文件被Unity识别
- 尝试 `BehaviorNodeRegistry.Refresh()`

### 问题：所有节点都不可见
**解决方案**：
- 检查是否至少配置了一个有效的程序集
- 如果希望显示所有节点，清空所有程序集配置

### 问题：运行时加载失败
**解决方案**：
- 检查行为树中使用的节点是否都在允许的程序集中
- 查看控制台错误信息了解具体原因

## 扩展建议

1. **自动检测**
   - 可以添加工具自动检测并列出可用的程序集

2. **批量配置**
   - 提供工具批量为多个行为树配置相同的程序集

3. **可视化依赖**
   - 在编辑器中显示程序集依赖关系图

4. **版本控制**
   - 记录程序集配置的变更历史